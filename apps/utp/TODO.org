Haphazard TODO list of things that needs attention:

* DONE Warn if we get old ACKs, there seem to be no control of this.
   We better have a check for this, otherwise we can simply add a
   large number of dumb errors to the code base later on.
* DONE We don't update the advertized window at all.
   We should begin planning how to handle the advertised window. We
   are currently killing the receiver because we are sending too fast
   and he has begun dropping packets.

   To make the window going:
   DONE ; Whenever we send out a packet, calculate the current window and
     stamp it into the packet
   DONE ; Figure out how to set the advertised window on outgoing packets.
   DONE ; Set window on outgoing advertised packets.

   DONE ; Figure out how to do this.
     It requires us to make a calculation based on the advertised
     window from the other end. When this is properly updated, we must
     calculate how many packets there are currently fitting into the
     window, and only send this amount to the other end.

   DONE ; When the connection is establishes, we will get an advertized
     window from the other end which we must obey. We don't currently.
   DONE ; When we receive a packet, be sure to make the correct window
     updates
   DONE ; When the packet fill code runs, we are currently shoving empty
     packets into the stream. This ought to be fixed - quickly.

   DONE ; Check that the window gets advertised correctly towards the other
     end.
   DONE ; Only send packets up to the window size.
  
   DONE ; Handle the special case of a zero packet window. It is a quite
     important special-case because you should only open up the window
     again, if a full packet can be injected in-flight. Otherwise, you
     must let the other end keep processing stuff.

   DONE ; Should ST_STATE packets bump the seq_no?

* DONE Figure out why our test fails
  The 2nd of our tests fail for some reason, but we need to know why
  exactly.

  Out test fails due to retransmissions it seems. We can thus try to
  implement retransmissions and see if this solves the problem!
* Retransmissions
  How should we handle retransmission of missing packets? This is
  needed before we can go to a check over the internet.
** DONE Propagate information if the ACK is moving ahead!
** DONE Set up a retransmission timer with a fairly large window of 3 seconds.
*** DONE Detect the need for retransmissions
    What are exactly the need for retransmissions?

    You should detect the case where there are no more bytes in-flight
    to send out. In that case, you should mark a message down with
    this information.
*** DONE Mark in the ACK-code when the in-flight buffer is empty
*** DONE Set up a retransmission timer and build a correct cancellation of it as well
*** DONE Handle the all_acked case in the retransmission timer as well.
    We are currently not handling this case correctly and we should.
** DONE Install the retransmissions code.
   Increase the timeout by two every time the retransmission timer ticks.
** DONE Write code for retransmitting the oldest frame
   With this, we gamble we only lost a single frame in the stream,
   though this is probably not going to be true in the general case
* DONE There is a bug when creating multiple connections, fix
  The second created connection seem to stall, and I wonder why. This
  should be investigated as the fix is needed to make the code work
  anyway!

  This error is interesting:

  ** exception error: no match of right hand side value 
                    {error,{already_started,<0.60.0>}}
     in function  gen_utp:connect/3
     in call from utp:test_connector_1/0
* TODO The ACK in the connectee@ is seen as old, investigate
  There is something along the lines of the numbering that doesn't
  work here. It ought to be fixed. But we place it down here to
  concentrate on other stuff first.

  The problem is that we find an ACK and that ACK is older than what
  we expect it to be. This is wrong, and we should fix it. We should
  get an ACK which is equivalent to the last acked packet. I.e., it
  should be equivalent to a window probe request. It is off-by-one and
  sometimes it is off by two (??).
* DONE ZeroWindow Timeouts
** DONE Move the Zerowindow check out of handle-packet. It has no place in there
** DONE Install and remove the zerowindow timeout
   When the window closes to 0, we should start the zerowindow
   timer. If nothing has happened for some time, we will then send out
   a window probe to coax the other end into sending back an ACK with
   an updated window.
*** DONE Installation
   When the window closes to 0, we should install the timer.
*** DONE UnInstallation
   If there is already a timer installed, remove it when the window
   opens above 0.
** DONE Figure out the exact construction of the window probe packet
   We don't know exactly what the probe packet looks like. We better
   read the source code of libutp to see what it looks like.

   There is no window probe packet. One simply bumps the window size
   >.< ... that is a majorly bad idea, but what the protocol does.
*** DONE Timer triggering
   If this timer triggers, it means we should send forth a
   window-probe packet. This is a packet which will trigger an ACK the
   other way.

   No, it means: Increase the window by one and then try to fill up
   the buffer if possible again!
* TODO Force an st_state packet through when the window *reopens*
  If we have a window that is down to 0, and we then suddenly get a
  receiver on the socket reading data out of it such that we detect
  the window open up again, we should always send a window update
  packet in this case.
* TODO Consider moving the window-specific code to its own module.
* TODO Re-read the uTP BEP 29 spec again
* DONE SYN Timeouts should just be part of retransmit timeouts?
  Yep, they should.
** DONE Read the libutp source and figure out the normal retransmit time for SYNs
   The normal retransmit time is two tries: one at 3 secs, one at 6
   secs and then at 12, we give up. OK. That should be easy to implement.
** DONE Set up the retransmit timer in uTP to match this.
** DONE Keep trying and fail if it takes too long upon timer triggers.
** DONE Ignore the special cases a bit for now.
* TODO Socket Close
  How to implement socket closedown?
** TODO Make a plan and understand what is going on!
   It is based on the idea of FIN packets. Does it allow half-open connections?
* TODO Test the retransmission code
** DONE Make DUMMYNET work on FreeBSD
** TODO Fix the zerowindow bug
* RTT Measurement
  This is probably different in uTP from the standard protocol
* TODO Only install the zerowin timer if there are more data to send out
  We are currently always setting the ZeroWindow timer when the
  peer_advertised_window is 0, but we could postpone that decision
  until we know we need to send data to the other end.
