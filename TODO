%%% Local Variables:
%%% mode: todoo
%%% End:
----------------------------------------------------------------------
-- This is a list of what To Do before a release is ready to be made.
--   Keep the style please. Can be read with emacs org-mode
----------------------------------------------------------------------

o [tuncer] Don't use the get_ prefix in mnesia table calls [Milestone: 0.9]
   It looks ugly and it is rather verbose. Just call it foo:by_id/1
   for instance.

o [tuncer] Consistently name by_ mnesia table calls. [Milestone: 0.9]
   The naming of calls in the mnesia manipulation tables are bad, they
   should be updated for consistency.

* For each module, go through it and think: Crash? [All milestones]
   For each module, go through it and think: Do we expect something to
   happen here? If yes, assume it happens and code such that if it is
   not the case, then the code crashes. Be aware that sometimes you
   _do_ actually need to know that something went wrong.

   For each case one must think. This is the 'let it crash' way of
   programming. Sparked by comments from Joe Armstrong.

- Missing module to check:
   lib/etorrent-1.0/src/etorrent_acceptor.erl
   lib/etorrent-1.0/src/etorrent_acceptor_sup.erl
   lib/etorrent-1.0/src/etorrent_app.erl

   lib/etorrent-1.0/src/etorrent_chunk.erl
   lib/etorrent-1.0/src/etorrent_dirwatcher.erl
   lib/etorrent-1.0/src/etorrent_dirwatcher_sup.erl
   lib/etorrent-1.0/src/etorrent_event.erl
   lib/etorrent-1.0/src/etorrent_fs_checker.erl
   lib/etorrent-1.0/src/etorrent_fs.erl
   lib/etorrent-1.0/src/etorrent_fs_pool_sup.erl
   lib/etorrent-1.0/src/etorrent_listener.erl

   lib/etorrent-1.0/src/etorrent_mnesia_init.erl
   lib/etorrent-1.0/src/etorrent_peer_communication.erl
   lib/etorrent-1.0/src/etorrent_peer.erl
   lib/etorrent-1.0/src/etorrent_piece.erl
   lib/etorrent-1.0/src/etorrent_sup.erl
   lib/etorrent-1.0/src/etorrent_t_manager.erl
   lib/etorrent-1.0/src/etorrent_torrent.erl
   lib/etorrent-1.0/src/etorrent_t_peer_group.erl
   lib/etorrent-1.0/src/etorrent_t_peer_pool_sup.erl
   lib/etorrent-1.0/src/etorrent_t_peer_recv.erl
   lib/etorrent-1.0/src/etorrent_t_peer_send.erl
   lib/etorrent-1.0/src/etorrent_t_pool_sup.erl

   lib/etorrent-1.0/src/etorrent_tracking_map.erl
   lib/etorrent-1.0/src/etorrent_t_sup.erl
   lib/etorrent-1.0/src/etorrent_utils.erl
   lib/etorrent-1.0/src/http_gzip.erl
   lib/etorrent-1.0/src/tracker_filter.erl
   lib/etorrent-1.0/src/tr.erl

o [jlouis] lists:map can be eaten with list comprehensions [Milestone: 0.9]
   For more succinct code we could use a list comprehension whenever
   we have a lists:map or a lists:filter. There are a few places where
   this can go in.

o [jlouis] What happens when 2 peers store the same piece at same time [Milestone: 0.9]
   This was an XXX inside the code. But it needs some serious thinking
   first as there is no easy fix for this.

o [jlouis] When initializing the tracker, get it to start right away. [Milestone: 0.9]
   We send it a 'start_now/0' message at the moment and that can
   possibly be removed.

* Add another state for #piece records [Milestone: 0.9]
   The state 'chunked_no_left' should indicate that the piece has been
   chunked, but there are no chunks left to pick from it. The state is
   introduced when we empty the #chunk record with not_fetched for the
   #piece and it is reintroduced in putback_chunks so we may again
   pick from it. Also, in the endgame, we should pick off from this
   state.

   It turns out to be an optimization, so put it into 0.9 for now.

* Installation and Build system [Milestone: 0.9]

- Set a kernel parameter for timer:start() [Milestone: 0.9]
   This is mentioned in timer(3erl), so better heed it.

- Let the system start with +Ktrue and +A 256 [Milestone: 0.9]
   Will greatly enhance the performance of the application.

- Consider using EMakefile

- Build proper installation target in makefile structure

* Implement graceful stopping of the etorrent application [Milestone: 1.0]
   The provisioning is there in OTP applications. We just need to
   leverage and use it.

* Make shutdown strategies right [Milestone: 1.0]
   Currently the shutdown strategies and cleanup strategies are wrong;
   for an explanation, see

   http://www.erlang.org/doc/design_principles/gen_server_concepts.html#2.6

   This should be fixed. Also note the t_peer_recv and t_peer_send
   might be living in an unhealthy relationship (send is a start_link
   on recv) and that this ought to be cleaned up, eventually by
   hooking both to a common ancestor supervisor (The overhead of doing
   so is not measurable).

* Who clean up what? [Milestone: 1.0]
   Go through each table and decide who "owns" the right to clean it
   up. It should definitely be checked.

* Disconnect from seeders [Milestone 1.0]
   Disconnect from seeders.

   While here, also check that we remember to report we have all of
   the torrent.

* Eradicate XXX and TODO [Milestone 1.0]
   Go through the code and remove all XXX and TODOs remaining
   there. There are a few that have been added when I find something
   disgusting in the code base.

* What should we do about bad peers? [Milestone: 1.0]
   Currently bad peers are those which are already connected. We ought
   to keep a list of baddies and blacklist them for some time if we
   don't like them anymore.

* It takes too much space to use #chunk_data [Milestone: 1.1]
   To fix this we can move store_chunk down and make it into an FS
   operation. That way we should be able to do it much much simpler
   than now. We also get rid of the store_piece call in
   etorrent_piece. All in all, the code will be much much simpler that
   way and will not have to keep that much data in memory.

* Profile and minimize the critical path [Milestone: 1.1]
   It looks like the critical path takes a wee bit too many clock
   cycles. It might be possible to cut it down considerably by
   profiling and optimizing that path.

   I want to do something about it, but not right now. Hence in
   Milestone 1.1.

* Use passive sockets [Milestone: 1.1]
   We need to use passive sockets at some point. The reason is that
   active sockets have no flow control, and the granularity of whole
   packets are bad from a choke/unchoke perspective. The code that
   needs change is rather contained, luckily, and can be placed in
   peer_communication.

   An even more sinister idea: change to active sockets when the rate
   of the peer exceeds a certain set amount to cut down the amount of
   processing needed. We *do* have some flow control as a peer will
   only send things we requested, so a peer can't overflow us by more
   than that anyway.

* DOCUMENTATION!
- Pick functions at random, and document what they are doing.
  It is /especially/ important to document library calls and
   non-standard internal functions in OTP modules.

* TorrentPeerMaster [Milestone: not decided]
- Figure out a better choking/unchoking algorithm.
  The current algorithm is the original one. We should look for a
   better algorithm and implement that. Suggestions for digging:
     ** Azureus
     ** Mainline
     ** Bittornado
     ** rtorrent

* Cleanups
- Decide what to do if we connect multiply to the same IP

* Temporary IP-ban on errors [Milestone: 1.1]
  If we find an error on a given peer, ban him temporarily for some
   time.

* ROBUSTNESS [Milestone: 1.2]
- In general, robustness is not really taken care of. We ought to make
  the system more robust by not relying so much on Pids etc.
- What happens if process X dies
  Go through all processes, and think about what happens if it
   dies. Ensure that the system is robust.
- List of processes to check for it:
   etorrent_acceptor.erl            etorrent_sup.erl
   etorrent_acceptor_sup.erl        etorrent_t_control.erl
   etorrent_bcoding.erl             etorrent_t_manager.erl
   etorrent_chunk.erl               etorrent_torrent.erl
   etorrent_dirwatcher.erl          etorrent_t_peer_group.erl
   etorrent_dirwatcher_sup.erl      etorrent_t_peer_pool_sup.erl
   etorrent.erl                     etorrent_t_peer_recv.erl
   etorrent_event.erl               etorrent_t_peer_send.erl
   etorrent_fs_checker.erl          etorrent_t_pool_sup.erl
   etorrent_fs.erl                  etorrent_tracker_communication.erl
   etorrent_fs_pool_sup.erl         etorrent_tracking_map.erl
   etorrent_t_sup.erl
   etorrent_listener.erl            etorrent_utils.erl
   etorrent_metainfo.erl            etorrent_version.hrl
   etorrent_mnesia_init.erl         http_gzip.erl
   etorrent_mnesia_table.hrl
   etorrent_peer_communication.erl
   etorrent_peer.erl                tr.erl
   etorrent_piece.erl


